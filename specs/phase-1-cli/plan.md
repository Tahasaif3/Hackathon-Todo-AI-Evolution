# Todo App Implementation Plan

## Technical Context

### Project Overview
- **Application**: Todo App console application
- **Technology Stack**: Python 3.13+, UV package manager
- **Architecture**: Console-based with separation of concerns (UI, Business Logic, Data Models)
- **Storage**: In-memory only (no persistent storage)
- **Features**: Add Task, View Tasks, Update Task, Delete Task, Mark Task Complete/Incomplete

### Dependencies
- Python 3.13+ standard library only (no external dependencies)
- UV package manager for project setup

### Integration Points
- Console UI connects to TaskManager for business logic
- TaskManager manages Task data models
- Main application orchestrates UI and TaskManager

### Known Unknowns
- Specific error handling requirements beyond basic validation
- Custom exception classes (NEEDS CLARIFICATION: What specific exception types should be used?)
- Logging implementation details (NEEDS CLARIFICATION: Should we implement logging and if so, to what level?)

## Constitution Check

### Compliance Verification
- ‚úÖ Code Generation Mandate: All code will be generated by Claude CLI
- ‚úÖ Python Console Application: Implementation will be a Python 3.13+ console app
- ‚úÖ In-Memory Storage: No external databases or persistent storage will be used
- ‚úÖ Five Core Features: All required features will be implemented
- ‚úÖ Clean Code Standards: Type hints, proper naming, error handling will be included
- ‚úÖ Spec-Driven Development: Implementation follows the provided specification
- ‚úÖ Architecture Requirements: Clear separation between UI, business logic, and data models
- ‚úÖ Code Quality: Type hints and docstrings will be included
- ‚úÖ User Experience: Clear CLI interface with helpful error messages
- ‚úÖ Error Handling: All error scenarios will be handled gracefully

## Phase 0: Research & Analysis

### Research Findings

#### Decision: Exception Handling Strategy
- **Rationale**: Following Python best practices for console applications, we'll create custom exception classes for domain-specific errors
- **Alternatives considered**: Using built-in exceptions vs. custom exceptions
- **Chosen approach**: Custom exceptions for better error categorization and handling

#### Decision: Date/Time Format
- **Rationale**: Using ISO 8601 format for consistent timestamp representation
- **Alternatives considered**: Various date formats
- **Chosen approach**: datetime.isoformat() for consistency with specification

#### Decision: Input Validation Approach
- **Rationale**: Centralized validation in TaskManager for consistency
- **Alternatives considered**: UI-level vs. Business logic level validation
- **Chosen approach**: Business logic level with UI-level error display

## Phase 1: Project Structure Setup

### Complete Directory Tree
```
todo-app/
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ CLAUDE.md
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îî‚îÄ‚îÄ todo_app/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ models/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ task.py
‚îÇ       ‚îú‚îÄ‚îÄ managers/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ task_manager.py
‚îÇ       ‚îî‚îÄ‚îÄ ui/
‚îÇ           ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îî‚îÄ‚îÄ console_ui.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_models.py
‚îÇ   ‚îú‚îÄ‚îÄ test_managers.py
‚îÇ   ‚îî‚îÄ‚îÄ test_ui.py
‚îî‚îÄ‚îÄ docs/
    ‚îî‚îÄ‚îÄ usage.md
```

### pyproject.toml Configuration
```toml
[project]
name = "todo-app"
version = "1.0.0"
description = "A console-based todo application"
authors = [{name = "Todo App Team", email = "todo@example.com"}]
readme = "README.md"
requires-python = ">=3.13"

[project.scripts]
todo-app = "src.main:main"

[tool.uv]
dev-dependencies = [
    "pytest>=8.0.0",
    "mypy>=1.0.0",
    "black>=24.0.0",
    "flake8>=7.0.0"
]
```

### __init__.py Files
- All packages will include empty `__init__.py` files to ensure proper Python package recognition

### Project Layout Explanation
- **src/**: Contains all source code
- **src/todo_app/models**: Data models (Task)
- **src/todo_app/managers**: Business logic (TaskManager)
- **src/todo_app/ui**: User interface components (ConsoleUI)
- **tests/**: Unit and integration tests
- **docs/**: Documentation files

## Phase 2: Data Model Implementation

### File: src/todo_app/models/task.py
```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class Task:
    """
    Represents a todo task with ID, title, description, status, and creation timestamp.
    """
    id: int
    title: str
    description: Optional[str] = None
    status: bool = False  # False = incomplete, True = complete
    created_date: str = None

    def __post_init__(self):
        if self.created_date is None:
            self.created_date = datetime.now().isoformat()

    def __str__(self) -> str:
        """
        Returns a string representation of the task for display purposes.
        """
        status_indicator = "‚úì" if self.status else " "
        return f"[{status_indicator}] {self.id}. {self.title}"
```

### Fields with Types and Defaults
- `id: int` - Auto-generated unique identifier
- `title: str` - Required task title (1-200 characters)
- `description: Optional[str]` - Optional task description (0-1000 characters)
- `status: bool` - Task completion status (default: False/incomplete)
- `created_date: str` - ISO format timestamp of creation

## Phase 3: Task Manager Implementation (Business Logic)

### File: src/todo_app/managers/task_manager.py
```python
from typing import List, Optional
from datetime import datetime
from ..models.task import Task

class TaskNotFoundError(Exception):
    """Raised when a task with a specific ID is not found."""
    pass

class ValidationError(Exception):
    """Raised when input validation fails."""
    pass

class TaskManager:
    """
    Manages in-memory collection of tasks with CRUD operations and validation.
    """

    def __init__(self):
        self._tasks: List[Task] = []
        self._next_id: int = 1

    def add_task(self, title: str, description: Optional[str] = None) -> Task:
        """
        Add a new task with validation.

        Args:
            title: Task title (1-200 characters)
            description: Optional task description (0-1000 characters)

        Returns:
            Task: The created task object

        Raises:
            ValidationError: If title or description validation fails
        """
        # Validate inputs
        if not title or len(title) < 1 or len(title) > 200:
            raise ValidationError("Title is required and must be between 1 and 200 characters")

        if description and len(description) > 1000:
            raise ValidationError("Description must be between 0 and 1000 characters")

        # Create task with auto-generated ID
        task = Task(
            id=self._next_id,
            title=title,
            description=description,
            status=False,
            created_date=datetime.now().isoformat()
        )

        self._tasks.append(task)
        self._next_id += 1

        return task

    def list_tasks(self, filter_type: str = "all") -> List[Task]:
        """
        Return filtered list of tasks.

        Args:
            filter_type: "all", "pending", or "completed"

        Returns:
            List[Task]: Filtered list of tasks
        """
        if filter_type == "pending":
            return [task for task in self._tasks if not task.status]
        elif filter_type == "completed":
            return [task for task in self._tasks if task.status]
        else:  # "all"
            return self._tasks

    def get_task(self, task_id: int) -> Task:
        """
        Find and return a task by ID.

        Args:
            task_id: The ID of the task to retrieve

        Returns:
            Task: The task object

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
        """
        for task in self._tasks:
            if task.id == task_id:
                return task
        raise TaskNotFoundError(f"Task with ID {task_id} not found")

    def update_task(self, task_id: int, title: Optional[str] = None,
                   description: Optional[str] = None) -> Task:
        """
        Update an existing task with validation.

        Args:
            task_id: The ID of the task to update
            title: New title (1-200 characters) or None to keep existing
            description: New description (0-1000 characters) or None to keep existing

        Returns:
            Task: The updated task object

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
            ValidationError: If validation of new values fails
        """
        task = self.get_task(task_id)

        # Validate new inputs if provided
        if title is not None:
            if not title or len(title) < 1 or len(title) > 200:
                raise ValidationError("Title must be between 1 and 200 characters")
            task.title = title

        if description is not None:
            if len(description) > 1000:
                raise ValidationError("Description must be between 0 and 1000 characters")
            task.description = description

        return task

    def delete_task(self, task_id: int) -> bool:
        """
        Remove a task by ID.

        Args:
            task_id: The ID of the task to delete

        Returns:
            bool: True if task was deleted, False if not found
        """
        task = self.get_task(task_id)
        self._tasks.remove(task)
        return True

    def mark_complete(self, task_id: int, completed: bool = True) -> Task:
        """
        Toggle or set the completion status of a task.

        Args:
            task_id: The ID of the task to update
            completed: Whether the task should be marked as complete (default: True)

        Returns:
            Task: The updated task object

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
        """
        task = self.get_task(task_id)
        task.status = completed
        return task

    def get_task_count(self, filter_type: str = "all") -> int:
        """
        Count tasks based on filter.

        Args:
            filter_type: "all", "pending", or "completed"

        Returns:
            int: Number of tasks matching the filter
        """
        return len(self.list_tasks(filter_type))
```

## Phase 4: Console UI Implementation

### File: src/todo_app/ui/console_ui.py
```python
from typing import Optional, List
from datetime import datetime
import re
from ..models.task import Task
from ..managers.task_manager import TaskManager, TaskNotFoundError, ValidationError

class ConsoleUI:
    """
    Console-based user interface for the todo application.
    """

    def __init__(self, task_manager: TaskManager):
        self.task_manager = task_manager

    def display_main_menu(self) -> None:
        """
        Show the main menu with all 6 options in ASCII design.
        """
        print("\n" + "="*50)
        print("           TODO APP v1.0")
        print("="*50)
        print(" 1. Add Task")
        print(" 2. View Tasks")
        print(" 3. Update Task")
        print(" 4. Delete Task")
        print(" 5. Mark Task Complete/Incomplete")
        print(" 6. Exit")
        print("="*50)

    def add_task_ui(self) -> None:
        """
        Feature 1 interface for adding tasks.
        """
        try:
            print("\n--- Add New Task ---")

            # Get title with validation
            title = input("Enter task title (1-200 characters): ").strip()

            # Get description (optional)
            description_input = input("Enter task description (optional, max 1000 chars): ").strip()
            description = description_input if description_input else None

            # Add task via manager
            task = self.task_manager.add_task(title, description)

            # Show success confirmation
            print(f"\n‚úÖ Task Added Successfully!")
            print(f"ID: {task.id}")
            print(f"Title: {task.title}")
            print(f"Description: {task.description or 'None'}")
            print(f"Status: {'Completed' if task.status else 'Incomplete'}")
            print(f"Created: {task.created_date}")

        except ValidationError as e:
            print(f"\n‚ùå Error: {str(e)}")
        except Exception as e:
            print(f"\n‚ùå Unexpected error: {str(e)}")

    def view_tasks_ui(self) -> None:
        """
        Feature 2 interface for viewing tasks with formatted table.
        """
        try:
            print("\n--- View Tasks ---")
            print("Filter options:")
            print(" 1. All tasks")
            print(" 2. Pending tasks")
            print(" 3. Completed tasks")

            filter_choice = input("Select filter (1-3, default 1): ").strip()

            # Determine filter type
            if filter_choice == "2":
                filter_type = "pending"
                filter_name = "Pending"
            elif filter_choice == "3":
                filter_type = "completed"
                filter_name = "Completed"
            else:
                filter_type = "all"
                filter_name = "All"

            # Get tasks
            tasks = self.task_manager.list_tasks(filter_type)
            task_count = self.task_manager.get_task_count(filter_type)

            # Display results
            if not tasks:
                print(f"\nüìã {filter_name} Tasks - No tasks found")
                return

            # Display header
            print(f"\nüìã TASK LIST ({filter_name} - {task_count} tasks)")
            print("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
            print("‚îÇ ID  ‚îÇ Title                       ‚îÇ Status   ‚îÇ Created             ‚îÇ")
            print("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")

            # Display each task
            for task in tasks:
                status_indicator = "[‚úì]" if task.status else "[ ]"
                formatted_title = task.title[:27] + "..." if len(task.title) > 27 else task.title
                formatted_date = self.format_date(task.created_date)

                print(f"‚îÇ {task.id:<3} ‚îÇ {formatted_title:<27} ‚îÇ {status_indicator:<7} ‚îÇ {formatted_date:<19} ‚îÇ")

            # Display footer
            print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")

        except Exception as e:
            print(f"\n‚ùå Unexpected error: {str(e)}")

    def update_task_ui(self) -> None:
        """
        Feature 3 interface for updating tasks.
        """
        try:
            print("\n--- Update Task ---")

            # Get task ID
            task_id_input = input("Enter task ID to update: ").strip()
            if not task_id_input.isdigit():
                print("\n‚ùå Error: Task ID must be a number")
                return

            task_id = int(task_id_input)

            # Get current task to show details
            current_task = self.task_manager.get_task(task_id)
            print(f"\nCurrent task details:")
            print(f"  ID: {current_task.id}")
            print(f"  Title: {current_task.title}")
            print(f"  Description: {current_task.description or 'None'}")
            print(f"  Status: {'Completed' if current_task.status else 'Incomplete'}")

            # Get new title (with option to keep existing)
            new_title_input = input(f"\nEnter new title (leave blank to keep '{current_task.title}'): ").strip()
            new_title = new_title_input if new_title_input else None

            # Get new description (with option to keep existing)
            current_desc = current_task.description or ""
            new_desc_input = input(f"Enter new description (leave blank to keep '{current_desc}'): ").strip()
            new_description = new_desc_input if new_desc_input != "" else None

            # Update task via manager
            updated_task = self.task_manager.update_task(task_id, new_title, new_description)

            # Show success confirmation
            print(f"\n‚úÖ Task Updated Successfully!")
            print(f"ID: {updated_task.id}")
            print(f"Title: {updated_task.title}")
            print(f"Description: {updated_task.description or 'None'}")
            print(f"Status: {'Completed' if updated_task.status else 'Incomplete'}")

        except TaskNotFoundError as e:
            print(f"\n‚ùå Error: {str(e)}")
        except ValidationError as e:
            print(f"\n‚ùå Error: {str(e)}")
        except Exception as e:
            print(f"\n‚ùå Unexpected error: {str(e)}")

    def delete_task_ui(self) -> None:
        """
        Feature 4 interface for deleting tasks with confirmation.
        """
        try:
            print("\n--- Delete Task ---")

            # Get task ID
            task_id_input = input("Enter task ID to delete: ").strip()
            if not task_id_input.isdigit():
                print("\n‚ùå Error: Task ID must be a number")
                return

            task_id = int(task_id_input)

            # Get task to show details before deletion
            task = self.task_manager.get_task(task_id)
            print(f"\nTask to delete:")
            print(f"  ID: {task.id}")
            print(f"  Title: {task.title}")
            print(f"  Description: {task.description or 'None'}")

            # Ask for confirmation
            confirm = input(f"\nAre you sure you want to delete this task? (Y/N): ").strip().lower()

            if confirm in ['y', 'yes']:
                # Delete task via manager
                self.task_manager.delete_task(task_id)

                # Show success message
                print(f"\n‚úÖ Task Deleted Successfully!")
                print(f"ID: {task.id}")
                print(f"Title: {task.title}")
            else:
                print(f"\n‚ùå Task deletion cancelled.")

        except TaskNotFoundError as e:
            print(f"\n‚ùå Error: {str(e)}")
        except Exception as e:
            print(f"\n‚ùå Unexpected error: {str(e)}")

    def mark_complete_ui(self) -> None:
        """
        Feature 5 interface for toggling task completion status.
        """
        try:
            print("\n--- Mark Task Complete/Incomplete ---")

            # Get task ID
            task_id_input = input("Enter task ID: ").strip()
            if not task_id_input.isdigit():
                print("\n‚ùå Error: Task ID must be a number")
                return

            task_id = int(task_id_input)

            # Get current task to show status
            current_task = self.task_manager.get_task(task_id)
            current_status = "Completed" if current_task.status else "Incomplete"
            new_status = "Incomplete" if current_task.status else "Completed"

            print(f"\nCurrent task: {current_task.title}")
            print(f"Current status: {current_status}")
            print(f"New status will be: {new_status}")

            # Toggle status via manager
            updated_task = self.task_manager.mark_complete(task_id, not current_task.status)

            # Show success confirmation
            print(f"\n‚úÖ Task Status Updated Successfully!")
            print(f"ID: {updated_task.id}")
            print(f"Title: {updated_task.title}")
            print(f"New Status: {'Completed' if updated_task.status else 'Incomplete'}")

        except TaskNotFoundError as e:
            print(f"\n‚ùå Error: {str(e)}")
        except Exception as e:
            print(f"\n‚ùå Unexpected error: {str(e)}")

    def format_task_row(self, task: Task) -> str:
        """
        Helper method to format task for table display.

        Args:
            task: The task to format

        Returns:
            str: Formatted task row
        """
        status_indicator = "[‚úì]" if task.status else "[ ]"
        formatted_title = task.title[:27] + "..." if len(task.title) > 27 else task.title
        formatted_date = self.format_date(task.created_date)

        return f"‚îÇ {task.id:<3} ‚îÇ {formatted_title:<27} ‚îÇ {status_indicator:<7} ‚îÇ {formatted_date:<19} ‚îÇ"

    def format_date(self, date_str: str) -> str:
        """
        Helper method to format timestamp nicely.

        Args:
            date_str: ISO format date string

        Returns:
            str: Formatted date string
        """
        try:
            dt = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
            return dt.strftime("%Y-%m-%d %H:%M")
        except:
            return date_str  # Return original if parsing fails

    def run(self) -> None:
        """
        Main loop handling all menu choices.
        """
        while True:
            try:
                self.display_main_menu()
                choice = input("\nEnter your choice (1-6): ").strip()

                if choice == "1":
                    self.add_task_ui()
                elif choice == "2":
                    self.view_tasks_ui()
                elif choice == "3":
                    self.update_task_ui()
                elif choice == "4":
                    self.delete_task_ui()
                elif choice == "5":
                    self.mark_complete_ui()
                elif choice == "6":
                    print("\nüëã Thank you for using Todo App. Goodbye!")
                    break
                else:
                    print("\n‚ùå Invalid choice. Please enter a number between 1-6.")

                # Pause before showing menu again
                input("\nPress Enter to continue...")

            except KeyboardInterrupt:
                print("\n\nüëã Application interrupted. Goodbye!")
                break
            except Exception as e:
                print(f"\n‚ùå An unexpected error occurred: {str(e)}")
                input("\nPress Enter to continue...")
```

## Phase 5: Main Application

### File: src/main.py
```python
#!/usr/bin/env python3
"""
Main entry point for the Todo App console application.
"""

from todo_app.managers.task_manager import TaskManager
from todo_app.ui.console_ui import ConsoleUI


def main() -> None:
    """
    Main function that initializes the application components and starts the UI loop.
    """
    try:
        # Initialize the task manager
        task_manager = TaskManager()

        # Initialize the console UI with the task manager
        console_ui = ConsoleUI(task_manager)

        # Start the application loop
        console_ui.run()

    except KeyboardInterrupt:
        print("\n\nüëã Application interrupted. Goodbye!")
    except Exception as e:
        print(f"\n‚ùå An unexpected error occurred: {str(e)}")
        print("Please try restarting the application.")


if __name__ == "__main__":
    main()
```

## Phase 6: Documentation

### File: README.md
```markdown
# Todo App

A console-based todo application built with Python 3.13+ featuring in-memory storage and a clean user interface.

## Features

- **Add Task**: Create new tasks with titles and optional descriptions
- **View Tasks**: Display tasks in a formatted table with filtering options
- **Update Task**: Modify existing task titles and descriptions
- **Delete Task**: Remove tasks with confirmation
- **Mark Complete/Incomplete**: Toggle task completion status

## Setup

### Prerequisites

- Python 3.13+
- UV package manager

### Installation

1. Clone the repository:
   ```bash
   git clone <repository-url>
   cd todo-app
   ```

2. Install dependencies using UV:
   ```bash
   uv sync
   ```

3. Run the application:
   ```bash
   uv run src/main.py
   ```

## Usage

The application provides a simple menu-driven interface:

1. **Add Task**: Enter a title (1-200 characters) and optional description (max 1000 characters)
2. **View Tasks**: Choose to view all, pending, or completed tasks in a formatted table
3. **Update Task**: Select a task by ID and modify its title or description
4. **Delete Task**: Select a task by ID and confirm deletion
5. **Mark Complete/Incomplete**: Toggle the completion status of a task
6. **Exit**: Close the application

## Project Structure

```
todo-app/
‚îú‚îÄ‚îÄ src/                    # Source code
‚îÇ   ‚îú‚îÄ‚îÄ main.py            # Application entry point
‚îÇ   ‚îî‚îÄ‚îÄ todo_app/          # Application modules
‚îÇ       ‚îú‚îÄ‚îÄ models/        # Data models
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ task.py    # Task data class
‚îÇ       ‚îú‚îÄ‚îÄ managers/      # Business logic
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ task_manager.py  # Task operations
‚îÇ       ‚îî‚îÄ‚îÄ ui/            # User interface
‚îÇ           ‚îî‚îÄ‚îÄ console_ui.py    # Console interface
‚îú‚îÄ‚îÄ tests/                 # Test files
‚îú‚îÄ‚îÄ docs/                  # Documentation
‚îî‚îÄ‚îÄ pyproject.toml         # Project configuration
```

## Development

This project follows spec-driven development principles. All code is generated using Claude CLI based on specifications in the `specs/` directory.

### Running Tests

```bash
uv run pytest
```

### Type Checking

```bash
uv run mypy src/
```

## License

MIT License - See LICENSE file for details.
```

### File: CLAUDE.md
```markdown
# Todo App - Claude CLI Development Guide

## Project Structure

This project follows the architecture specified in the constitution and implements all five required features:

- **Data Models**: Located in `src/todo_app/models/`
- **Business Logic**: Located in `src/todo_app/managers/`
- **User Interface**: Located in `src/todo_app/ui/`
- **Entry Point**: `src/main.py`

## Development Workflow

### Code Generation

All code for this project must be generated using Claude CLI. Manual code changes are prohibited per the project constitution.

### Implementation Process

1. Specifications are written first in the `specs/` directory
2. Implementation plans are created based on specifications
3. Code is generated following the implementation plan
4. Tests are implemented to verify functionality
5. Implementation is verified against the original specification

### Quality Standards

- All functions must have type hints
- All public methods must have docstrings
- Maximum cyclomatic complexity of 5 per function
- Maximum 50 lines per function
- Meaningful variable and function names
- Proper error handling with custom exceptions

### Architecture

The application follows a clear separation of concerns:

- **Models**: Define data structures (Task)
- **Managers**: Handle business logic (TaskManager)
- **UI**: Handle user interaction (ConsoleUI)
- **Main**: Orchestrates the application

## Key Components

### Task Model
- Dataclass with ID, title, description, status, and creation timestamp
- Automatic ID generation starting from 1
- Default incomplete status
- ISO format timestamp for creation date

### Task Manager
- In-memory storage of tasks
- CRUD operations for tasks
- Input validation
- Custom exception handling

### Console UI
- Menu-driven interface
- Formatted table display for tasks
- Input validation and error handling
- User-friendly messages

## Testing Strategy

Tests should cover:
- All five core features
- Input validation scenarios
- Error handling
- Edge cases
- Integration between components

## Deployment

The application is a console application with in-memory storage. No deployment beyond running the Python script is required.
```

## Phase 7: Testing Strategy

### Comprehensive Test Checklist

#### Feature 1: Add Task (6+ test scenarios)
- [ ] Test adding a task with valid title and no description
- [ ] Test adding a task with valid title and description
- [ ] Test adding a task with minimum length title (1 character)
- [ ] Test adding a task with maximum length title (200 characters)
- [ ] Test adding a task with maximum length description (1000 characters)
- [ ] Test validation error for empty title
- [ ] Test validation error for title too long (>200 chars)
- [ ] Test validation error for description too long (>1000 chars)
- [ ] Test auto-generation of unique task IDs

#### Feature 2: View Tasks (6+ test scenarios)
- [ ] Test viewing all tasks when none exist (empty list)
- [ ] Test viewing all tasks when multiple tasks exist
- [ ] Test viewing pending tasks only
- [ ] Test viewing completed tasks only
- [ ] Test viewing with mixed pending and completed tasks
- [ ] Test proper formatting of task table
- [ ] Test correct status indicators ([ ] and [‚úì])

#### Feature 3: Update Task (5+ test scenarios)
- [ ] Test updating task title only
- [ ] Test updating task description only
- [ ] Test updating both title and description
- [ ] Test keeping existing values when inputs are empty
- [ ] Test validation error for invalid title during update
- [ ] Test error when updating non-existent task
- [ ] Test updating with maximum length inputs

#### Feature 4: Delete Task (5+ test scenarios)
- [ ] Test successful deletion of existing task
- [ ] Test error when deleting non-existent task
- [ ] Test confirmation prompt behavior
- [ ] Test deletion of last remaining task
- [ ] Test that deleted task no longer appears in task list

#### Feature 5: Mark Task Complete/Incomplete (4+ test scenarios)
- [ ] Test marking incomplete task as complete
- [ ] Test marking complete task as incomplete
- [ ] Test error when toggling non-existent task
- [ ] Test status change reflects in task list display

#### Integration Tests (all features working together)
- [ ] Test complete workflow: add ‚Üí view ‚Üí update ‚Üí mark ‚Üí delete
- [ ] Test multiple operations on the same task
- [ ] Test operations on multiple different tasks
- [ ] Test error handling doesn't break application flow
- [ ] Test application state consistency after all operations

## File Dependency Diagram

```
src/main.py
    ‚Üì
ConsoleUI ‚Üê‚Üí TaskManager
    ‚Üì           ‚Üì
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Task (data model)
```

## Integration Points Between Components

1. **Main ‚Üí ConsoleUI**: Main initializes ConsoleUI with TaskManager instance
2. **ConsoleUI ‚Üí TaskManager**: ConsoleUI calls TaskManager methods for all business operations
3. **TaskManager ‚Üí Task**: TaskManager creates and manages Task objects
4. **ConsoleUI ‚Üí Task**: ConsoleUI displays Task objects in formatted output
5. **TaskManager ‚Üí ConsoleUI**: TaskManager raises exceptions that ConsoleUI handles and displays

## Implementation Notes

### Method Signatures

#### TaskManager Methods:
- `add_task(self, title: str, description: Optional[str] = None) -> Task`
- `list_tasks(self, filter_type: str = "all") -> List[Task]`
- `get_task(self, task_id: int) -> Task`
- `update_task(self, task_id: int, title: Optional[str] = None, description: Optional[str] = None) -> Task`
- `delete_task(self, task_id: int) -> bool`
- `mark_complete(self, task_id: int, completed: bool = True) -> Task`
- `get_task_count(self, filter_type: str = "all") -> int`

#### ConsoleUI Methods:
- `display_main_menu(self) -> None`
- `add_task_ui(self) -> None`
- `view_tasks_ui(self) -> None`
- `update_task_ui(self) -> None`
- `delete_task_ui(self) -> None`
- `mark_complete_ui(self) -> None`
- `format_task_row(self, task: Task) -> str`
- `format_date(self, date_str: str) -> str`
- `run(self) -> None`

### Implementation Logic Details

#### Validation Logic:
- Input validation occurs in TaskManager methods
- ConsoleUI displays validation errors to users
- All validation messages follow the specification format

#### Error Handling:
- Custom exceptions for domain-specific errors
- Graceful error handling without application crashes
- User-friendly error messages as specified

#### Data Flow:
- All data operations go through TaskManager
- ConsoleUI only handles presentation and user input
- Clear separation between business logic and UI concerns